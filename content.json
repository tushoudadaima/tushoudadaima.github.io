{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"算法第四版1.1习题个人解","date":"2022-05-04T04:35:18.103Z","updated":"2022-05-04T12:02:16.704Z","comments":true,"path":"2022/05/04/算法第四版1.1习题个人解/","link":"","permalink":"http://example.com/2022/05/04/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%881.1%E4%B9%A0%E9%A2%98%E4%B8%AA%E4%BA%BA%E8%A7%A3/","excerpt":"","text":"算法第四版1.1习题个人解33页 1.1.31234567891011int a,b,c;a=b=c=0;StdOut.println(&quot;Please enter three numbers&quot;);a = StdIn.readInt();b = StdIn.readInt();c = StdIn.readInt();if(a == b &amp;&amp; b == c) &#123; StdOut.println(&quot;equal&quot;);&#125;else &#123; StdOut.println(&quot;not equal&quot;);&#125; 33页 1.1.5123456789double x;double y;x = StdIn.readDouble();y = StdIn.readDouble();if(0 &lt; x &amp;&amp; x &lt; 1 &amp;&amp; 0 &lt; y &amp;&amp; y &lt; 1) &#123; StdOut.println(&quot;true&quot;);&#125;else &#123; StdOut.println(&quot;false&quot;);&#125; 34页 1.1.1112345678910boolean[][] one = &#123;&#123;true,false,true&#125;,&#123;false,false,true&#125;,&#123;true,true,false&#125;&#125;;for(int x = 1; x &lt;= one.length; x++) &#123; for(int y = 1; y &lt;= one[0].length; y++) &#123; if(one[x-1][y-1]) &#123; StdOut.println(&quot;行号为：&quot; + x + &quot;,列号为:&quot; + y + &quot;数据为：&quot; + &quot;*&quot;); &#125;else &#123; StdOut.println(&quot;行号为：&quot; + x + &quot;,列号为:&quot; + y + &quot;数据为：&quot; + &quot; &quot;); &#125; &#125;&#125; 34页 1.1.1312345678910111213141516171819202122232425public static void main(String[] args) &#123; int[][] testList; StdOut.println(&quot;请输入两个整数：&quot;); int M = StdIn.readInt(); int N = StdIn.readInt(); testList = MyList(M,N); int[][] testListTwo = new int[N][M]; for(int x = 0; x &lt; N; x++) &#123; for(int y = 0; y &lt; M; y++) &#123; testListTwo[x][y] = testList[y][x]; &#125; &#125;&#125;//随机生成二维数组private static int[][] MyList(int m, int n)&#123; int[][] one = new int[m][n]; for(int x = 0; x &lt; m; x++) &#123; for(int y = 0; y &lt; n; y++) &#123; one[x][y] = StdRandom.uniform(10); &#125; &#125; return one;&#125; 34页 1.1.141234567891011121314151617181920private static int lg(double N) &#123; if(N &gt;= 1) &#123; int count = 1; int sum = 2; while(sum &lt;= N) &#123; count++; sum *= 2; &#125; return count - 1; &#125;else if(N &gt; 0) &#123; int count = -1; double sum = 1.0 / 2; while(sum &gt; N) &#123; count--; sum /= 2; &#125; return count; &#125; return -1;&#125; 34页 1.1.1512345678910111213141516171819public static int[] histogram(int[] a, int M) &#123; int length = a.length; int[] array = new int[M]; int number = 0; for(int i = 0; i &lt; M; i++) &#123; int count = 0; for(int j = 0; j &lt; length; j++) &#123; if(a[j] == i) &#123; count++; &#125; &#125; number += count; array[i] = count; if(number == length) &#123; break; &#125; &#125; return array;&#125; 36页 1.1.3112345678910111213141516171819202122232425262728293031323334353637383940//画圆private static void drawRic() &#123; StdDraw.setXscale(0, 100); StdDraw.setYscale(0, 100); StdDraw.setPenRadius(0.01); StdDraw.setPenColor(StdDraw.BLACK); StdDraw.circle(50, 50, 50);&#125;//画点private static Position[] drawPoint(int n) &#123; StdDraw.setPenRadius(0.05); StdDraw.setPenColor(StdDraw.RED); StdDraw.point(0, 50); Position[] position = new Position[n]; position[0] = new Position(0, 50); double angle = 2 * Math.PI / n; for(int i = 1; i &lt;= n-1; i++) &#123; double angle_two = angle * i; double x = 50 - 50 * Math.cos(angle_two); double y = 50 + 50 * Math.sin(angle_two); StdDraw.setPenRadius(0.05); StdDraw.setPenColor(StdDraw.RED); StdDraw.point(x, y); position[i] = new Position(x, y); &#125; return position;&#125;//概率连线private static void createLine(Position[] position, double p) &#123; int length = position.length; StdDraw.setPenRadius(0.01); StdDraw.setPenColor(StdDraw.GREEN); for(int i = 0; i &lt; length; i++) &#123; for(int j = i+1 ; j &lt; length; j++) &#123; if(StdRandom.bernoulli(p)) &#123; StdDraw.line(position[i].getX(), position[i].getY(), position[j].getX(), position[j].getY()); &#125; &#125; &#125;&#125; 36页 1.1.33123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Matrix &#123; //向量点乘 public static double dot(double[] x, double[] y) &#123; double sum = 0; int length = x.length; for(int i = 0; i &lt; length; i++) &#123; sum += x[i] * y[i]; &#125; return sum; &#125; //矩阵和矩阵之积 public static double[][] mult(double[][] a, double[][] b)&#123; int x = a.length; int y = b[0].length; double[][] result = new double[x][y]; double[][] tansA = transpose(b); for(int i = 0; i &lt; x; i++) &#123; for(int j = 0; j &lt; y; j++) &#123; result[i][j] = dot(a[i], tansA[j]); &#125; &#125; return result; &#125; //转置矩阵 public static double[][] transpose(double[][] a)&#123; int x = a.length; int y = a[0].length; double[][] result = new double[y][x]; for(int i = 0; i &lt; y; i++) &#123; for(int j = 0; j &lt; x; j++) &#123; result[i][j] = a[j][i]; &#125; &#125; return result; &#125; //矩阵和向量之积 public static double[] mult(double[][] a, double[] x) &#123; int length = a.length; double[] result = new double[length]; for(int i = 0; i &lt; length; i++) &#123; result[i] = dot(a[i], x); &#125; return result; &#125; //向量和矩阵之积 public static double[] mult(double[] y, double[][] a) &#123; int length = a[0].length; double[] result = new double[length]; double[][] tansA = transpose(a); for(int i = 0; i &lt; length; i++) &#123; result[i] = dot(y, tansA[i]); &#125; return result; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"计算网络自顶向下","date":"2022-05-04T04:35:18.099Z","updated":"2020-08-04T12:27:08.397Z","comments":true,"path":"2022/05/04/计算网络自顶向下/","link":"","permalink":"http://example.com/2022/05/04/%E8%AE%A1%E7%AE%97%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/","excerpt":"","text":"1.1.1 因特网具体构成描述当前分组交换机最著名的类型是路由器和链路层交换机； 因特网服务提供商（Internet Service Provider, ISP）； 传输控制协议（Transmission Control Protocol, TCP）； 网际协议（Internet Protocol, IP）；","categories":[],"tags":[]},{"title":"","slug":"Typora_demo","date":"2022-05-04T04:35:18.095Z","updated":"2020-08-04T12:17:45.681Z","comments":true,"path":"2022/05/04/Typora_demo/","link":"","permalink":"http://example.com/2022/05/04/Typora_demo/","excerpt":"","text":"Typora的部分基础用法仅供参考！ [toc] Start（区域元素）菜单输入[toc]，按下换行，产生标题，自动更新 段落按下换行建立新的一行 标题#表示开始，一共有六个级别（标题），#的个数表示各个级别，#后加空格加文字，换行结束 注释以&gt;开头，后加文字，换行下一行，双击换行跳出 示例 序列有序序列以1.开头，后加文字，创建有序序列 无序序列以*或+或-开头，后加文字，创建无序序列，换行下一行，shift+tab跳出 代码块以&#96;&#96;&#96;开头，加上语言名开启代码块，换行下一行，下键跳出 1System.out.println(&quot;效果&quot;); 数学块以$$开头，换行创建输入区域$$V1 * V2 &#x3D; ?$$ 表格类似|one|two|的形式，换行创建 脚注在文字后使用[^]，^后加文字，然后添加信息 示例^demo 水平线输入***或—，换行创建 Next（特征元素）链接[]里添加超链接文字，后面加()里面定义链接 点击百度跳转：百度 图片 手动添加，类似链接，前面加上！ 直接拖动鼠标进去，然后鼠标点击图片修改 斜体用* *或者_括住 试试 试试 加粗用** **括住 试试 试试 删除线用~~ ~~括住 试试 试试 下划线使用HTML标签 试试 试试 代码用&#96;&#96;括住在正常段落表示代码 比如main()这样","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-05-04T04:31:26.020Z","updated":"2022-05-04T04:31:26.021Z","comments":true,"path":"2022/05/04/hello-world/","link":"","permalink":"http://example.com/2022/05/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}